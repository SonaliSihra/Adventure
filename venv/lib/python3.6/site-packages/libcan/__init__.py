__version__ = "2.0"
__copyright__ = "Copyright (C) 2007-2009 Lars Gustaebel"

BUFSIZE = 32 * 1024

import locale
TEXT_ENCODING = locale.getpreferredencoding()

def text_encode(s):
    return s.encode(TEXT_ENCODING, "replace")

def text_decode(s):
    try:
        return s.decode(TEXT_ENCODING)
    except UnicodeDecodeError:
        raise UnicodeError("unable to decode '%s' with encoding '%s'" % (s, TEXT_ENCODING))


import sys
FS_ENCODING = sys.getfilesystemencoding()

def fs_encode(s):
    return s.encode(FS_ENCODING)

def fs_decode(s):
    try:
        return s.decode(FS_ENCODING)
    except UnicodeDecodeError:
        raise UnicodeError("unable to decode '%s' with encoding '%s'" % (s, FS_ENCODING))


import logging

class ConsoleFormatter(logging.Formatter):
    """A custom formatter that produces are nicer output
       for the console. For DEBUG and INFO levels it just
       prints out the message, for all levels above also
       the levelname (like "WARNING", "CRITICAL", etc) is
       printed out.
    """

    def format(self, record):
        record.message = record.getMessage()

        if record.levelno >= logging.WARN:
            s = "%(levelname)s: %(message)s" % record.__dict__
        else:
            s = "%(message)s" % record.__dict__

        if record.exc_info:
            if s[-1] != "\n":
                s = s + "\n"
            s = s + self.formatException(record.exc_info)
        return s


def init_logging(verbose):
    if verbose == 0:
        level = logging.WARN
    elif verbose == 1:
        level = logging.INFO
    elif verbose == 2:
        level = logging.DEBUG
    else:
        level = logging.NOISE

    root = CanLogger("root", level)
    logging.root = root
    logging.noise = root.noise

    hdlr = logging.StreamHandler()
    fmtr = ConsoleFormatter()
    hdlr.setFormatter(fmtr)
    root.addHandler(hdlr)


class CanLogger(logging.Logger):

    def noise(self, msg, *args, **kwargs):
        if self.manager.disable >= logging.NOISE:
            return
        if logging.NOISE >= self.getEffectiveLevel():
            apply(self._log, (logging.NOISE, msg, args), kwargs)

    def _log(self, level, msg, args, exc_info=None, extra=None):
        new_args = []
        for arg in args:
            if type(arg) is unicode:
                new_args.append(text_encode(arg))
            else:
                new_args.append(arg)
        args = tuple(new_args)
        logging.Logger._log(self, level, msg, args, exc_info, extra)

logging.NOISE = 5
logging.addLevelName(logging.NOISE, "NOISE")
logging.setLoggerClass(CanLogger)

