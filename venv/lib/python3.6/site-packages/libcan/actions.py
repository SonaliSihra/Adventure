import sys
import os
import time
import errno
import logging
import tarfile
import pwd, grp
import zlib
import glob

from libcan import text_encode, text_decode, fs_encode, fs_decode, BUFSIZE
from libcan.matcher import Includer, Excluder
from libcan.filesystem import FilesystemReader, FileReader
from libcan.snapshot import SnapshotCollection, SnapshotWriter, SnapshotError
from libcan.differ import Differ
from libcan.file import REG, DIR, SYM, LNK, SPR, CHR, BLK, FIFO, SOCK
from libcan.filter import COMPRESS_GZIP, COMPRESS_BZIP2, GzipReader, BZ2Reader, ChecksumReader


class Actions(object):
    """A collection of actions for creation and management
       of backup snapshots.
    """

    def __init__(self, opts, args):
        self.opts = opts
        self.args = args

        # Prepare exclusion patterns.
        self.excluder = Excluder()

        if opts.excludefrom:
            for pattern in open(opts.excludefrom):
                pattern = pattern.strip()
                self.excluder.add(pattern)

        if opts.excludes:
            for pattern in opts.excludes:
                self.excluder.add(pattern)

    def create(self):
        """Create a backup snapshot.
        """
        collection = SnapshotCollection.from_name(self.opts.source, self.opts.keyfile)

        snreader = collection.get_last_snapshot()
        if snreader is not None:
            logging.debug("use %s as comparison snapshot", os.path.basename(snreader.filename))

        if self.opts.filesfrom:
            fsreader = FileReader(self.opts.directory, self.opts.filesfrom)
        else:
            # Expand shell patterns in arguments.
            arguments = set()
            for pattern in self.args:
                paths = glob.glob(fs_encode(os.path.join(self.opts.directory,pattern)))
                if not paths:
                    raise SystemExit("%s does not exist" % pattern)
                for path in paths:
                    try:
                        path = fs_decode(path)
                    except UnicodeError, e:
                        logging.warn(e)
                        continue

                    path = os.path.normpath(path)
                    if path.startswith(self.opts.directory):
                        arguments.add(path[len(self.opts.directory):].lstrip("/"))
                    else:
                        raise SystemExit("%s is not inside %s" % (text_encode(path), text_encode(self.opts.directory.encode)))
            fsreader = FilesystemReader(self.opts.directory, arguments, self.excluder, self.opts.max_size, self.opts.one_file_system, self.opts.exclude_tag)

        if snreader is not None:
            serial = snreader.serial + 1
        else:
            serial = 0

        try:
            snwriter = SnapshotWriter(self.opts.source, self.opts.directory,
                    serial, self.opts.compression, self.opts.keyfile)
        except (EnvironmentError, SnapshotError), e:
            logging.error(e)
            sys.exit(1)

        try:
            differ = iter(Differ(snreader or [], fsreader))
        except Exception, e:
            logging.error(e)
            sys.exit(1)

        while True:
            try:
                file = differ.next()
            except StopIteration:
                break
            except EnvironmentError, e:
                logging.error(e)
                break

            if file.is_new():
                logging.info("N %s", file.name)

            elif file.is_modified():
                logging.info("U %s", file.name)

            elif file.is_deleted():
                logging.info("D %s", file.name)

            try:
                snwriter.add(file)
            except EnvironmentError, e:
                logging.error(e)
                sys.exit(1)

        fsreader.close()
        snwriter.close()
        collection.close()

    def list(self):
        """List files from a backup snapshot.
        """
        try:
            collection = SnapshotCollection.from_snapshot(self.opts.source, self.opts.keyfile, ignore_corrupt=True)
            snapshot = collection.get_snapshot_by_name(self.opts.source)
        except EnvironmentError, e:
            logging.error(e)
            sys.exit(1)

        includer = Includer(self.args)
        while True:
            try:
                file = snapshot.next()
            except EOFError:
                break

            if file.isref():
                if self.opts.list_new:
                    continue
                else:
                    file = snapshot.dereference(file)

            if includer.match(file.name) and not self.excluder.match(file.name):
                if self.opts.verbose:
                    print tarfile.filemode(file.mode),
                    print text_encode(file.uname), text_encode(file.gname),
                    print "%10d" % file.size,
                    print "%d-%02d-%02d %02d:%02d" % time.localtime(file.mtime)[:5],

                print text_encode(file.name),

                if self.opts.verbose:
                    if file.issym():
                        print "->", text_encode(file.link),
                print

    def extract(self):
        """Extract files from a backup snapshot.
        """
        try:
            collection = SnapshotCollection.from_snapshot(self.opts.source, self.opts.keyfile)
            snapshot = collection.get_snapshot_by_name(self.opts.source)
        except EnvironmentError, e:
            logging.error(e)
            sys.exit(1)

        includer = Includer(self.args)
        extractor = Extractor(snapshot, includer, self.excluder, self.opts.directory)
        extractor.extract()

    def test(self):
        """Test the integrity of a backup snapshot.
        """
        try:
            collection = SnapshotCollection.from_snapshot(self.opts.source, self.opts.keyfile)
            snapshot = collection.get_snapshot_by_name(self.opts.source)
        except EnvironmentError, e:
            logging.error(e)
            sys.exit(1)

        extractor = Extractor(snapshot, None, None, None)
        extractor.test()


class Extractor(object):

    def __init__(self, snapshot, includer, excluder, directory):
        self.snapshot = snapshot
        self.includer = includer
        self.excluder = excluder
        self.directory = directory

    def set_metadata(self, file):
        logging.debug("set_metadata(%s)\n  mode:    0%o,\n  atime:   %s,\n  mtime:   %s",
                file.name,
                file.mode & 0777,
                time.asctime(time.localtime(file.atime)),
                time.asctime(time.localtime(file.mtime)))

        path = os.path.join(self.directory, file.name)

        if file.type != SYM:
            os.chmod(path, file.mode)
            os.utime(path, (file.atime, file.mtime))

        if os.geteuid() == 0:
            try:
                g = grp.getgrnam(file.gname)[2]
            except KeyError:
                try:
                    g = grp.getgrgid(file.gid)[2]
                except KeyError:
                    g = os.getgid()
            try:
                u = pwd.getpwnam(file.uname)[2]
            except KeyError:
                try:
                    u = pwd.getpwuid(file.uid)[2]
                except KeyError:
                    u = os.getuid()
            os.lchown(path, u, g)

    def extract(self):
        directories = []
        for file in self.snapshot:
            while directories and not file.name.startswith(directories[-1].name):
                self.set_metadata(directories.pop())

            if not self.includer.match(file.name) or self.excluder.match(file.name):
                continue

            logging.info(file.name)

            path = os.path.join(self.directory, file.name)
            dirname = os.path.dirname(path)

            if not os.path.exists(dirname):
                try:
                    os.makedirs(dirname)
                except EnvironmentError, e:
                    logging.error(e)

            if file.type == DIR:
                try:
                    os.mkdir(path)
                except OSError, e:
                    if e.errno != errno.EEXIST:
                        # Ignore existing directories.
                        raise
                directories.append(file)

            elif file.type == REG:
                if os.path.exists(path):
                    os.remove(path)
                if file.compression == COMPRESS_GZIP:
                    a = GzipReader(file.fileobj, file.compressed_size)
                elif file.compression == COMPRESS_BZIP2:
                    a = BZ2Reader(file.fileobj, file.compressed_size)
                else:
                    a = file.fileobj
                a = ChecksumReader(a)
                b = open(path, "wb")
                s = file.size
                while s > 0:
                    buf = a.read(min(BUFSIZE, s))
                    if not buf:
                        logging.warn("premature end of snapshot")
                        break
                    b.write(buf)
                    s -= len(buf)
                b.close()
                a.close()
                if s != 0:
                    logging.warn("%s: wrong size", file.name)
                if file.checksum != a.get_checksum():
                    logging.warn("%s: checksum comparison failed", file.name)
                self.set_metadata(file)

            elif file.type == SYM:
                if os.path.exists(path):
                    os.remove(path)
                os.symlink(file.link, path)
                self.set_metadata(file)

            else:
                logging.warn("%s: cannot extract unsupported filetype %d", file.name, file.type)

        while directories:
            self.set_metadata(directories.pop())

    def test(self, abort_on_error=False):
        for file in self.snapshot:
            logging.info(file.name)
            if file.type == REG:
                if file.compression == COMPRESS_GZIP:
                    a = GzipReader(file.fileobj, file.compressed_size)
                elif file.compression == COMPRESS_BZIP2:
                    a = BZ2Reader(file.fileobj, file.compressed_size)
                else:
                    a = file.fileobj
                a = ChecksumReader(a)
                s = file.size
                while s > 0:
                    buf = a.read(min(BUFSIZE, s))
                    if not buf:
                        break
                    s -= len(buf)
                a.close()
                if s != 0:
                    if abort_on_error:
                        raise ValueError("wrong size: %r" % file.name)
                    else:
                        logging.warn("%s: wrong size", file.name)
                if file.checksum != a.get_checksum():
                    if abort_on_error:
                        raise ValueError("bad checksum: %r" % file.name)
                    else:
                        logging.warn("%s: bad checksum", file.name)

