import sys
import os
import stat
import pwd
import grp
import logging

from libcan import fs_encode, fs_decode
from libcan.binary import *
from libcan.matcher import Excluder

UNCHANGED, NEW, MODIFIED, DELETED = range(4)

REG, DIR, SYM, LNK, SPR, CHR, BLK, FIFO, SOCK = range(9)

TYPE_FILE, TYPE_REFERENCE = range(2)
TYPE_EOF = 255


class File(object):
    """Store file information.
    """

    @classmethod
    def from_name(cls, root, name):
        obj = cls()
        obj.state = UNCHANGED

        status = os.lstat(os.path.join(root, name))

        obj.name = name
        obj.mode = status.st_mode

        if stat.S_ISREG(status.st_mode):
            obj.size = status.st_size
        else:
            obj.size = 0

        obj.atime = max(0, status.st_atime)
        obj.mtime = max(0, status.st_mtime)
        obj.ctime = max(0, status.st_ctime)

        obj.device = status.st_dev
        obj.inode = status.st_ino

        obj.uid = status.st_uid & 0xffffffff
        obj.gid = status.st_gid & 0xffffffff
        try:
            obj.uname = pwd.getpwuid(obj.uid)[0]
        except KeyError:
            obj.uname = ""
        try:
            obj.gname = grp.getgrgid(obj.gid)[0]
        except KeyError:
            obj.gname = ""

        # XXX hard links?
        if stat.S_ISREG(status.st_mode):
            obj.type = REG
        elif stat.S_ISDIR(status.st_mode):
            obj.type = DIR
        elif stat.S_ISLNK(status.st_mode):
            obj.type = SYM
            # In Python < 2.6 os.readlink() does not work with unicode objects.
            if sys.version_info[:2] < (2, 6):
                try:
                    obj.link = fs_decode(os.readlink(fs_encode(os.path.join(root, name))))
                except UnicodeError, e:
                    logging.warn(e)
                    return None
            else:
                obj.link = os.readlink(os.path.join(root, name))
        elif stat.S_ISCHR(status.st_mode):
            obj.type = CHR
            obj.devmajor = os.major(status.st_rdev)
            obj.devminor = os.minor(status.st_rdev)
        elif stat.S_ISBLK(status.st_mode):
            obj.type = BLK
            obj.devmajor = os.major(status.st_rdev)
            obj.devminor = os.minor(status.st_rdev)
        elif stat.S_ISFIFO(status.st_mode):
            obj.type = FIFO
        elif stat.S_ISSOCK(status.st_mode):
            obj.type = SOCK
        else:
            return None

        return obj

    @classmethod
    def from_snapshot(cls, fileobj):
        obj = cls()
        obj.state = UNCHANGED

        obj.serial = unpack_large(fileobj)

        obj.type = unpack_small(fileobj)
        obj.size = unpack_large(fileobj)
        obj.mode = unpack_large(fileobj)
        obj.atime = unpack_large(fileobj) / 1000
        obj.mtime = unpack_large(fileobj) / 1000
        obj.ctime = unpack_large(fileobj) / 1000
        obj.device = unpack_large(fileobj)
        obj.inode = unpack_large(fileobj)
        obj.uid = unpack_large(fileobj)
        obj.gid = unpack_large(fileobj)
        obj.name = unpack_string(fileobj)
        obj.uname = unpack_string(fileobj)
        obj.gname = unpack_string(fileobj)

        if obj.type in (CHR, BLK):
            obj.devmajor = unpack_large(fileobj)
            obj.devminor = unpack_large(fileobj)

        if obj.type == SYM:
            obj.link = unpack_string(fileobj)

        obj.fileobj = fileobj
        return obj

    @property
    def metadata(self):
        return {
            "mode":     self.mode,
            "uid":      self.uid,
            "gid":      self.gid,
            "uname":    self.uname,
            "gname":    self.gname
        }

    @property
    def contents(self):
        return {
            "type":     self.type,
            "mtime":    self.mtime,
            "size":     self.size
        }

    @property
    def status(self):
        d = self.metadata.copy()
        d.update(self.contents)
        return d

    def isreg(self):
        return self.type == REG

    def isdir(self):
        return self.type == DIR

    def issym(self):
        return self.type == SYM

    def isref(self):
        return False

    def __eq__(self, other):
        return self.status == other.status

    def __ne__(self, other):
        return self.status != other.status

    def __cmp__(self, other):
        return cmp(self.name, other.name)

    def __repr__(self):
        return "<File %r>" % self.name

    # -- State
    def set_unchanged(self):
        self.state = UNCHANGED

    def is_unchanged(self):
        return self.state == UNCHANGED

    def is_changed(self):
        return self.state != UNCHANGED

    def set_new(self):
        self.state = NEW

    def is_new(self):
        return self.state == NEW

    def set_modified(self):
        self.state = MODIFIED

    def is_modified(self):
        return self.state == MODIFIED

    def set_deleted(self):
        self.state = DELETED

    def is_deleted(self):
        return self.state == DELETED

    def is_compressed(self):
        return compressedpatterns.match(self.name)

    # ---
    def write_metadata(self, fileobj):
        fileobj.write(pack_small(self.type))
        fileobj.write(pack_large(self.size))
        fileobj.write(pack_large(self.mode))
        fileobj.write(pack_large(self.atime * 1000))
        fileobj.write(pack_large(self.mtime * 1000))
        fileobj.write(pack_large(self.ctime * 1000))
        fileobj.write(pack_large(self.device))
        fileobj.write(pack_large(self.inode))
        fileobj.write(pack_large(self.uid))
        fileobj.write(pack_large(self.gid))
        fileobj.write(pack_string(self.name))
        fileobj.write(pack_string(self.uname))
        fileobj.write(pack_string(self.gname))

        if self.type in (CHR, BLK):
            fileobj.write(pack_large(self.devmajor))
            fileobj.write(pack_large(self.devminor))

        if self.type == SYM:
            fileobj.write(pack_string(self.link))


class Reference(object):

    def __repr__(self):
        return "<Reference snapshot:%d, offset: %06x, target:%d>" % (self.snapshot, self.offset, self.target)

    def isref(self):
        return True

    @classmethod
    def from_snapshot(cls, fileobj):
        obj = cls()
        obj.serial = unpack_large(fileobj)
        obj.snapshot = unpack_large(fileobj)
        obj.offset = unpack_large(fileobj)
        obj.target = unpack_large(fileobj)
        return obj

    @classmethod
    def from_file(cls, file):
        obj = cls()
        obj.snapshot = file.snapshot
        obj.offset = file.offset
        obj.target = file.serial
        return obj

    def write_reference(self, fileobj):
        fileobj.write(pack_large(self.snapshot))
        fileobj.write(pack_large(self.offset))
        fileobj.write(pack_large(self.target))


class CompressedPatterns(object):

    def __init__(self):
        self.filenames = ["/etc/can/compressed.list", os.path.expanduser("~/.can/compressed.list")]

        self.patterns = set()
        for filename in self.filenames:
            if not os.path.exists(filename):
                continue

            for line in open(filename):
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                self.patterns.add(line)

        self.matcher = Excluder(self.patterns)

    def match(self, filename):
        return self.matcher.match(filename)

compressedpatterns = CompressedPatterns()

