import sys
import os
import zlib
import bz2
import tempfile
import cStringIO
import hashlib

from libcan import BUFSIZE

COMPRESS_CONST = 5
COMPRESS_NONE, COMPRESS_GZIP, COMPRESS_BZIP2, COMPRESS_GZIP_ALL, COMPRESS_BZIP2_ALL = range(COMPRESS_CONST)
ENCRYPT_CONST = 2
ENCRYPT_NONE, ENCRYPT_BLOWFISH = range(ENCRYPT_CONST)

# Limit in-memory tempfiles to 32 megabytes.
TMP_LIMIT = 32 * 1024 * 1024


class GzipReader(object):

    # size is the compressed size!!

    def __init__(self, fobj, size):
        self.fobj = fobj
        self.size = size
        self.filter = self.create_filter()

        self.buf = ""
        self.bpos = 0   # position in the buffer
        self.rpos = 0   # real (uncompressed) position
        self.cpos = 0   # position in the compressed data
        self.eof = False

    def create_filter(self):
        return zlib.decompressobj()

    def use_filter(self, buf):
        return self.filter.decompress(buf)

    def read(self, size):
        while not self.eof and size + self.bpos > len(self.buf):
            if self.size is not None:
                bufsize = min(BUFSIZE, self.size - self.cpos)
                if bufsize == 0:
                    self.eof = True
                    break
            else:
                bufsize = BUFSIZE
            buf = self.fobj.read(bufsize)
            if not buf:
                self.eof = True
                break
            self.cpos += len(buf)
            self.buf += self.use_filter(buf)

        buf = self.buf[self.bpos:self.bpos + size]
        self.bpos += len(buf)
        if self.bpos > BUFSIZE:
            self.buf = self.buf[self.bpos:]
            self.bpos = 0
        self.rpos += len(buf)
        return buf

    def seek(self, pos):
        assert pos >= self.tell()
        self.skip(pos - self.tell())

    def skip(self, size):
        while True:
            buf = self.read(min(size, BUFSIZE))
            if not buf:
                break
            size -= len(buf)

    def tell(self):
        return self.rpos

    def close(self):
        pass


class BZ2Reader(GzipReader):

    def create_filter(self):
        return bz2.BZ2Decompressor()


class BlowfishReader(GzipReader):

    def __init__(self, fobj, password):
        self.password = password
        super(BlowfishReader, self).__init__(fobj, None)

    def create_filter(self):
        from Crypto.Cipher import Blowfish
        return Blowfish.new(self.password)

    def use_filter(self, buf):
        return self.filter.decrypt(buf)

class PlainReader(object):

    def __init__(self, fobj, size):
        assert size is None, "PlainReader takes no size argument"
        self.fobj = fobj
        self.offset = fobj.tell()
        self.read = fobj.read

    def seek(self, pos):
        self.fobj.seek(pos + self.offset)

    def tell(self):
        return self.fobj.tell() - self.offset

    def close(self):
        pass


class GzipWriter(object):

    def __init__(self, fobj):
        self.fobj = fobj
        self.filter = self.create_filter()
        self.closed = False

    def create_filter(self):
        return zlib.compressobj()

    def write(self, buf):
        assert not self.closed
        buf = self.filter.compress(buf)
        if buf:
            # Avoid needless calls to write().
            self.fobj.write(buf)

    def finish(self):
        assert not self.closed
        self.fobj.write(self.filter.flush())
        if hasattr(self.fobj, "finish"):
            self.fobj.finish()
        self.closed = True

    def close(self):
        if not self.closed:
            self.finish()


class BZ2Writer(GzipWriter):

    def create_filter(self):
        return bz2.BZ2Compressor()


class BlowfishWriter(object):

    blocksize = 8
    assert BUFSIZE % blocksize == 0

    def __init__(self, fobj, password):
        self.fobj = fobj

        from Crypto.Cipher import Blowfish
        self.filter = Blowfish.new(password)
        self.buf = ""
        self.closed = False

    def write(self, buf):
        assert not self.closed
        self.buf += buf
        while len(self.buf) >= BUFSIZE:
            self.fobj.write(self.filter.encrypt(self.buf[:BUFSIZE]))
            self.buf = self.buf[BUFSIZE:]

    def finish(self):
        assert not self.closed

        blocks = int(len(self.buf) / self.blocksize)
        self.fobj.write(self.filter.encrypt(self.buf[:blocks * self.blocksize]))
        self.buf = self.buf[blocks * self.blocksize:]

        if len(self.buf):
            self.buf += "\0" * (self.blocksize - len(self.buf))

        self.fobj.write(self.filter.encrypt(self.buf))
        if hasattr(self.fobj, "finish"):
            self.fobj.finish()

    def close(self):
        if not self.closed:
            self.finish()


class ChecksumReader(object):

    def __init__(self, fobj):
        self.fobj = fobj
        self.checksum = 0

    def read(self, size):
        buf = self.fobj.read(size)
        self.checksum = zlib.adler32(buf, self.checksum)
        return buf

    def get_checksum(self):
        return self.checksum & 0xFFFFFFFF

    def close(self):
        pass


class ChecksumWriter(object):

    def __init__(self, fobj):
        self.fobj = fobj
        self.checksum = 0
        self.closed = False

    def write(self, buf):
        assert not self.closed
        self.checksum = zlib.adler32(buf, self.checksum)
        self.fobj.write(buf)

    def get_checksum(self):
        return self.checksum & 0xFFFFFFFF

    def finish(self):
        assert not self.closed
        self.fobj.finish()

    def close(self):
        if not self.closed:
            self.finish()


class TempFile(object):

    def __init__(self):
        self.memory = True
        self.fobj = cStringIO.StringIO()
        self.closed = False

    def read(self, bufsize):
        assert not self.closed
        return self.fobj.read(bufsize)

    def tell(self):
        assert not self.closed
        return self.fobj.tell()

    def finish(self):
        assert not self.closed
        if hasattr(self.fobj, "finish"):
            self.fobj.finish()

    def close(self):
        if not self.closed:
            self.finish()
        self.fobj.close()

    def write(self, buf):
        assert not self.closed
        self.fobj.write(buf)
        if self.memory and self.fobj.tell() > TMP_LIMIT:
            size = self.fobj.tell()
            self.fobj.seek(0)
            new = tempfile.NamedTemporaryFile(prefix="can.tmpfile.")
            while size > 0:
                buf = self.fobj.read(min(size, BUFSIZE))
                if not buf:
                    break
                size -= len(buf)
                new.write(buf)
            self.fobj.close()
            self.fobj = new
            self.memory = False

    def rewind(self):
        assert not self.closed
        self.fobj.seek(0)

