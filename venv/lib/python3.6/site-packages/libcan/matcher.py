import sys
import os
import re


class Rollback(Exception):
    pass

class ParseError(Exception):
    pass


class Parser(object):

    def __init__(self, pattern):
        self.patterns = pattern.split(os.sep)
        self.index = 0

    def parse(self):
        regexes = []
        for pattern in self.patterns:
            regex = self.f_expr(pattern)
            regex = re.compile("^" + regex + "$")
            regexes.append(regex)
        #print (self.patterns, [r.pattern for r in regexes])
        return regexes

    def f_expr(self, s, stopchars=None):
        pattern = ""
        while s:
            if s[0] == "\\":
                if not s[1:]:
                    raise ParseError("lonely backslash")
                if s[1] in "[]{}":
                    pattern += "\\" + s[1]
                else:
                    pattern += s[1]
                s = s[2:]
            elif s[0] == ".":
                pattern += r"\."
                s = s[1:]
            elif s[0] == "?":
                if not pattern:
                    pattern += "[^\.]"
                else:
                    pattern += "."
                s = s[1:]
            elif s[0] == "*":
                if not pattern:
                    pattern += "[^\.].*?"
                else:
                    pattern += ".*?"
                s = s[1:]
            elif s[0:2] == "[!":
                pattern += "[^"
                p, s = self.f_brackets(s[2:])
                pattern += p
            elif s[0] == "[":
                pattern += "["
                p, s = self.f_brackets(s[1:])
                pattern += p
            elif s[0] == "{":
                try:
                    p, s = self.f_braces(s[1:])
                    pattern += "(" + p
                except Rollback:
                    pattern += s[0]
                    s = s[1:]
            elif stopchars is not None and s[0] in stopchars:
                return pattern, s
            else:
                pattern += s[0]
                s = s[1:]
        if stopchars is not None:
            raise Rollback
        return pattern

    def f_brackets(self, s):
        pattern = ""
        while s:
            if s[0] == "]":
                return pattern + "]", s[1:]
            elif s[0] == "\\":
                if not s[1:]:
                    raise ParseError("lonely backslash")
                pattern += s[1]
                s = s[2:]
            elif s[0] == "-":
                if not pattern or s[1:2] == "]":
                    pattern += r"\-"
                else:
                    pattern += "-"
                s = s[1:]
            else:
                pattern += s[0]
                s = s[1:]
        else:
            raise ParseError("premature end of expression")

    def f_braces(self, s):
        pattern = ""
        found_comma = False
        while s:
            if s[0] == "\\":
                if not s[1:]:
                    raise ParseError("lonely backslash")
                pattern += s[1]
                s = s[2:]
            elif s[0] == "}":
                if not found_comma:
                    # e.g. "a{bc}d" -> literal
                    raise Rollback
                return pattern + ")", s[1:]
            elif s[0] == ",":
                found_comma = True
                pattern += "|"
                s = s[1:]
            else:
                p, s = self.f_expr(s, "},")
                pattern += p
        else:
            raise ParseError("premature end of expression")



class Matcher(object):

    def __init__(self, patterns=None):
        self.regexes = []
        if patterns is not None:
            for pattern in patterns:
                self.add(pattern)

    def add(self, pattern):
        regexes = Parser(pattern).parse()
        self.regexes.append(regexes)


class Includer(Matcher):

    def match(self, filename):
        if not self.regexes:
            return True

        components = filename.split(os.sep)
        for regexes in self.regexes:
            if len(regexes) > len(components):
                continue
            for i, regex in enumerate(regexes):
                if not regex.match(components[i]):
                    break
            else:
                return True
        return False


class Excluder(Matcher):

    def match(self, filename):
        components = filename.split(os.sep)
        for regexes in self.regexes:
            if len(regexes) > len(components):
                # e.g. "a/dir????/*.tgz" - "b/foo.tgz"
                continue
            match = False
            i = 0
            while True:
                r = regexes[:]
                c = components[:len(components)-i]
                if len(r) > len(c):
                    break
                while r:
                    if not r.pop().match(c.pop()):
                        match = False
                        break
                else:
                    match = True
                if match:
                    break
                i += 1
            if match:
                return True
        return False


